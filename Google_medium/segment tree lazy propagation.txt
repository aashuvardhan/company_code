/*

https://www.geeksforgeeks.org/dsa/lazy-propagation-in-segment-tree/


*/



#include <bits/stdc++.h>
using namespace std;



int range_query(vector<int>& tree,int tree_ind,int low,int high,int q_start,int q_end,vector<int>& lazy){
    
    //step 1:-
    
    // If lazy value is non-zero for current node of segment
    // tree, then there are some pending updates. So we need
    // to make sure that the pending updates are done before
    // making new updates.
    if(lazy[tree_ind]!=0){
        tree[tree_ind]+=(high-low+1)*lazy[tree_ind];
        
        // checking if it is not leaf node because if
        // it is leaf node then we cannot go further
        
        if(low!=high){
            lazy[2*tree_ind+1]+=lazy[tree_ind];
            lazy[2*tree_ind+2]+=lazy[tree_ind];
        }
        lazy[tree_ind]=0;
    }
    
    // step2:-
    
    // out of range
    
    if(low>high or low>q_end or high<q_start){
        return 0;
    }
    
    // step3:-
    // Current segment is fully in range
    
    if(low>=q_start and high<=q_end){
        return tree[tree_ind];
    }
    
    //step4:- 
    // if it does not lie fully
    int mid=(low+high)/2;
    
    return range_query(tree,2*tree_ind+1,low,mid,q_start,q_end,lazy)+
            range_query(tree,2*tree_ind+2,mid+1,high,q_start,q_end,lazy);
    
    
    
    
    
}




void range_update(vector<int>& tree,int tree_ind,int low,int high,int up_start,int up_end,int val,vector<int>& lazy){
    
    //step 1:-
    
    // If lazy value is non-zero for current node of segment
    // tree, then there are some pending updates. So we need
    // to make sure that the pending updates are done before
    // making new updates.
    if(lazy[tree_ind]!=0){
        
        tree[tree_ind]+=(high-low+1)*lazy[tree_ind];
        
        // checking if it is not leaf node because if
        // it is leaf node then we cannot go further
        if(low!=high){
            lazy[2*tree_ind+1]+=lazy[tree_ind];
            lazy[2*tree_ind+2]+=lazy[tree_ind];
        }
        
        // Set the lazy value for current node as 0 as it
        // has been updated
        lazy[tree_ind]=0;
        
    }
    
    // step2:-
    
    // out of range
    if(low>high or low>up_end or high<up_start){
        return;
    }
    
    // step3:-
    // Current segment is fully in range
    
    if(low>=up_start and high<=up_end){
    
        tree[tree_ind]+=(high-low+1)*val;
        
        if(low!=high){
            lazy[2*tree_ind+1]+=val;
            lazy[2*tree_ind+2]+=val;
        }
        
        return;
        
    }
    
    //step4:- 
    //not completely in the range
    int mid=(low+high)/2;
    
    range_update(tree,2*tree_ind+1,low,mid,up_start,up_end,val,lazy);
    range_update(tree,2*tree_ind+2,mid+1,high,up_start,up_end,val,lazy);
    
    tree[tree_ind]=tree[2*tree_ind+1]+tree[2*tree_ind+2];
    
    
}



int construct(vector<int>& arr,vector<int>& tree,int low,int high,int tree_ind){
    
    if(low==high){
        tree[tree_ind]=arr[low];
        return arr[low];
    }
    
    int mid=(low+high)/2;
    
    int left=construct(arr,tree,low,mid,2*tree_ind+1);
    int right=construct(arr,tree,mid+1,high,2*tree_ind+2);
    
    tree[tree_ind]=left+right;
    return tree[tree_ind];
    
}



int main() {
	// your code goes here
	
	vector<int> arr={1, 3, 5, 7, 9, 11};
	
	int n=arr.size();
	
	vector<int> tree(4*n,0);
	vector<int> lazy(4*n,0);
	
	construct(arr,tree,0,n-1,0);
	
	/*
	for(auto ele: tree){
	    cout<<ele<<"  ";
	}
	*/
	
	cout<<range_query(tree,0,0,n-1,1,3,lazy)<<endl;
	
	
	range_update(tree,0,0,n-1,1,5,10,lazy);
	
	cout<<range_query(tree,0,0,n-1,1,3,lazy)<<endl;
	
	
	
	
	

}
