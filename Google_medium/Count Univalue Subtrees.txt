/*

https://leetcode.com/problems/count-univalue-subtrees/description/


https://algo.monster/liteproblems/250


You are given the root of a binary tree. Your task is to count how many uni-value subtrees exist in the tree.

A uni-value subtree is a subtree where all nodes have the same value. This means that starting from any node in the tree, if you consider it as the root of a subtree, all nodes within that subtree (including the node itself, its children, grandchildren, and so on) must have identical values for it to qualify as a uni-value subtree.

For example:

A single leaf node is always a uni-value subtree (since it has no children)
A subtree with root value 5 and two children both with value 5 would be a uni-value subtree
A subtree with root value 5, left child 5, and right child 3 would NOT be a uni-value subtree
The solution uses a depth-first search (DFS) approach that traverses the tree from bottom to top. For each node, it checks:

Whether the left subtree is uni-value
Whether the right subtree is uni-value
Whether the current node's value matches its children's values (if they exist)
The function returns True if the current subtree is uni-value and False otherwise. When a uni-value subtree is found, the counter ans is incremented. The clever part is handling null children - if a child doesn't exist, the code treats it as having the same value as the parent node (a = root.val if root.left is None else root.left.val).

The algorithm counts all uni-value subtrees by checking each node and its descendants, ultimately returning the total count.


*/


#include <bits/stdc++.h>
using namespace std;

struct Treenode{
    int val;
    Treenode* left;
    Treenode* right;
    
    Treenode(int x){
        val=x;
        left=NULL;
        right=NULL;
    }
};


bool count_unival(Treenode* root,int& count){
    
    if(root==NULL){
        return true;
    }
    
    
    
    if(root->left==NULL and root->right==NULL){
        count++;
        return true;
    }
    
    bool left=count_unival(root->left,count);
    bool right=count_unival(root->right,count);
    
    if(left==false or right==false){
        return false;
    }else{
        if(root->left and root->left->val!=root->val){
            return false;
        }
        if(root->right and root->right->val!=root->val){
            return false;
        }
        count++;
        return true;
    }
    
    
    
}



int main() {
	// your code goes here
	Treenode* root=new Treenode(5);
	root->left=new Treenode(4);
	root->left->left=new Treenode(3);
	root->left->right=new Treenode(4);
	
	root->right=new Treenode(4);
	root->right->right=new Treenode(4);
	int count=0;
	count_unival(root,count);
	cout<<count;
	
	
	

}
