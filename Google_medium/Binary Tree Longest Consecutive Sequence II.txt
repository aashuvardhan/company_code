/*

https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii

https://algo.monster/liteproblems/549

You are given the root of a binary tree and need to find the length of the longest consecutive path in the tree.

A consecutive path consists of nodes where each consecutive pair of nodes has values that differ by exactly 1. The path can be either increasing (like [1,2,3,4]) or decreasing (like [4,3,2,1]). Mixed patterns like [1,2,4,3] are not valid consecutive paths.

The key aspect of this problem is that the path doesn't have to follow the traditional parent-to-child direction. Instead, it can go through any connected nodes in the tree, including paths that go child-parent-child. This means a valid path could start from a node in the left subtree, go up through the parent, and continue down into the right subtree, as long as the values remain consecutive.

For example, if you have a tree structure where a parent node has value 2, its left child has value 1, and its right child has value 3, then the path [1,2,3] going from left child through parent to right child would be a valid consecutive path of length 3.

The task is to find the maximum length among all such possible consecutive paths in the tree.


*/


#include <bits/stdc++.h>
using namespace std;

struct Treenode{
    int val;
    Treenode* left;
    Treenode* right;
    Treenode(int x){
        val=x;
        left=NULL;
        right=NULL;
    }
};


vector<int> traversal(Treenode* root,int& maxLength ){
    if(root==NULL){
        return {0,0};
    }
    if(root->left==NULL and root->right==NULL){
        return {1,1};
    }
    
    
    vector<int> left=traversal(root->left,maxLength);
    vector<int> right=traversal(root->right,maxLength);
    
    int incr=1;
    int decr=1;
    
    if(root->left!=NULL){
        if(root->left->val+1==root->val){
            incr=left[0]+1;
        }else if(root->left->val-1==root->val){
            decr=left[1]+1;
        }
    }
    
    if(root->right!=NULL){
        if(root->right->val+1==root->val){
            incr=max(incr,right[0]+1);
        }else if(root->right->val-1==root->val){
            decr=max(decr,right[1]+1);
        }
    }
    
    maxLength=max(maxLength,incr+decr-1);
    return {incr,decr};
    
    
}




int main() {
	// your code goes here
	
	Treenode* root=new Treenode(5);
	root->left=new Treenode(4);
	root->left->left=new Treenode(3);
	root->left->left->right=new Treenode(2);
	root->left->right=new Treenode(3);
	
	root->right=new Treenode(7);
	root->right->left=new Treenode(6);
	
	int maxLength=INT_MIN;
	
	traversal(root,maxLength);
	
	cout<<maxLength;
	

}
