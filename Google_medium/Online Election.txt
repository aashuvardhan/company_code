/*

https://leetcode.com/problems/online-election/description/


You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].

For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.

Implement the TopVotedCandidate class:

TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.
int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.


*/


vector<int> winner;
    vector<int> timer;
    int prev_winner=-1;

    int find_candidate(unordered_map<int,int>& umap,int curr_candi){

        int candidate=-1;
        int count=0;
        for(auto ele: umap){
            if(ele.second>=count){
                count=ele.second;
                candidate=ele.first;
            }
        }
        if(umap[curr_candi]==count){
            candidate=curr_candi;
        }else if(umap[prev_winner]==count){
            candidate=prev_winner;
        }
        return candidate;
    }

    TopVotedCandidate(vector<int>& persons, vector<int>& times) {
        
        timer=times;
        unordered_map<int,int> umap;

        for(int i=0;i<times.size();i++){
            umap[persons[i]]++;
            int candidate=find_candidate(umap,persons[i]);

            winner.push_back(candidate);
            prev_winner=candidate;

        }
    }
    
    int q(int t) {

        auto it=lower_bound(timer.begin(),timer.end(),t);
        int index=it-timer.begin();
        cout<<index<<"   ";
        int n=timer.size();

        if(index>=n){
            return winner[n-1];
        }
        if(timer[index]>t){
            return winner[index-1];
        }else{
            return winner[index];
        }
    }